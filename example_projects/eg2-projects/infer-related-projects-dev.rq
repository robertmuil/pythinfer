PREFIX ptp: <http://example.org/pythinfer/project/>
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

# ===== SPARQL CONSTRUCT: Project Relationships =====
# 
# This query infers that two projects are related if they share external
# data sources (reference vocabularies). Projects are considered related if
# their external data shares either the same isVersionOf source OR the same
# inputPattern. This type of graph traversal and aggregation is difficult
# to express in OWL-RL and benefits from procedural query logic.
#
# It demonstrates:
# 1. Complex path traversal (project -> external data -> other projects)
# 2. Aggregation and filtering logic (finding common vocabularies)
# 3. Conditional inference based on graph patterns
#

CONSTRUCT {
    ?project1 ptp:relatedProject ?project2 ;
        ptp:sharesExternalSources ?count ;
        ptp:relationshipType "shared-vocabularies" .
}
WHERE {
    # Find projects that share external data sources (by isVersionOf or inputPattern)
    ?project1 a ptp:Project ;
        ptp:hasExternalData ?externalData1 .
    
    ?project2 a ptp:Project ;
        ptp:hasExternalData ?externalData2 .
    
    # Match if either isVersionOf or inputPattern are the same
    {
        ?externalData1 dct:isVersionOf ?edSource .
        ?externalData2 dct:isVersionOf ?edSource .
    }
    UNION
    {
        ?externalData1 ptp:inputPattern ?pattern .
        ?externalData2 ptp:inputPattern ?pattern .
    }
    
    # Ensure we don't relate a project to itself
    FILTER (?project1 != ?project2)
    
    # Count how many external sources are shared (optional enrichment)
    # {
    #     SELECT ?project1 ?project2 (COUNT(DISTINCT ?externalData1) as ?count)
    #     WHERE {
    #         ?project1 a ptp:Project ;
    #             ptp:hasExternalData ?externalData1 .
            
    #         ?project2 a ptp:Project ;
    #             ptp:hasExternalData ?externalData1 .
            
    #         FILTER (?project1 != ?project2)
    #     }
    #     GROUP BY ?project1 ?project2
    #     HAVING (?count >= 1)
    # }
}
