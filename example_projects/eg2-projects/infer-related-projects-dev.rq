PREFIX dct: <http://purl.org/dc/terms/>
PREFIX eg: <http://www.example.org/>
PREFIX file: <>
PREFIX ptp: <http://example.org/pythinfer/project/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

# ===== SPARQL CONSTRUCT: Project Relationships =====
# 
# This query infers that two projects are related if they share external
# data sources (reference vocabularies). Projects are considered related if
# their external data shares either the same isVersionOf source OR the same
# inputPattern. This type of graph traversal and aggregation is difficult
# to express in OWL-RL and benefits from procedural query logic.
#
# It demonstrates:
# 1. Complex path traversal (project -> external data -> other projects)
# 2. Aggregation and filtering logic (finding common vocabularies)
# 3. Conditional inference based on graph patterns
#

# CONSTRUCT {
#    # Create a ProjectRelationship between related projects
#    [] a ptp:ProjectRelationship ;
#        ptp:hasParticipant ?project1, ?project2 ;
#        ptp:relationshipWeight ?count ;
#        ptp:sharedDataSource ?sharedExternalSource ;
#        .
# }
# WHERE {
    # Find projects that share external data sources
    # This should abide sameAs links if the OWL-RL has been applied
    # ?project1 a ptp:Project ;
    #     ptp:hasExternalData ?sharedExternalSource .
    
    # ?project2 a ptp:Project ;
    #     ptp:hasExternalData ?sharedExternalSource .

    # # Ensure we don't relate a project to itself
    # FILTER (?project1 != ?project2)
    
    # Count how many external sources are shared (optional enrichment)
    # {
        SELECT
            ?project1
            ?project2
            (COUNT(DISTINCT ?sharedExternalSource) as ?countRaw)
            (COUNT(DISTINCT ?canonicalSource) as ?countCanonical)
            (GROUP_CONCAT(DISTINCT ?canonicalSource; SEPARATOR="|") as ?canonicalSources)
            (GROUP_CONCAT(DISTINCT ?sourceLabel; SEPARATOR="|") as ?sourceLabels)
        WHERE {
            ?project1 a ptp:Project ;
                ptp:hasExternalData ?sharedExternalSource .

            ?project2 a ptp:Project ;
                ptp:hasExternalData ?sharedExternalSource .

            OPTIONAL {
                ?sharedExternalSource dct:title|rdfs:label ?sourceLabel .
            }

            OPTIONAL {
                ?sharedExternalSource dct:isVersionOf ?sharedVersionOf .
            }
            OPTIONAL {
                ?sharedExternalSource ptp:inputPattern ?sharedInputPattern .
            }
            BIND(COALESCE(?sharedVersionOf, URI(CONCAT("file://", ?sharedExternalSource))) AS ?canonicalSource)

            FILTER (?project1 != ?project2)
        }
        GROUP BY ?project1 ?project2
#     }
# }
