PREFIX dct: <http://purl.org/dc/terms/>
PREFIX eg: <http://www.example.org/>
PREFIX ptp: <http://example.org/pythinfer/project/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>


# ===== SPARQL CONSTRUCT: Project Relationships =====
# 
# This query infers that two projects are related if they share external
# data sources (reference vocabularies). Projects are considered related if
# their external data shares either the same isVersionOf source OR the same
# inputPattern. This type of graph traversal and aggregation is difficult
# to express in OWL-RL and benefits from procedural query logic.
#
# It demonstrates:
# 1. Complex path traversal (project -> external data -> other projects)
# 2. Aggregation and filtering logic (finding common vocabularies)
# 3. Conditional inference based on graph patterns
#

CONSTRUCT {
   # Create a ProjectRelationship between related projects
   ?rel a ptp:ProjectRelationship ;
       ptp:hasParticipant ?project1, ?project2 ;
       ptp:relationshipWeight ?countCanonical ;
       ptp:fullSharedCount ?countRaw ;
       ptp:sharedDataSourceLabel ?sourceLabels ;
       .
   
   # Add individual assertions for each shared data source
   ?rel ptp:sharedCanonicalDataSource ?canonicalSource .
   ?rel ptp:sharedDataSource ?sharedExternalSource .

   # This kludge forces the serialisation to give a specific blank node ID (_:<id>) to the sharedExternalSource
   <arbitrary_anchor> ptp:pullOut ?sharedExternalSource .
}
WHERE {
    # First, get the aggregated counts per project pair
    {
        SELECT
            ?project1
            ?project2
            (COUNT(DISTINCT ?sharedExternalSource) as ?countRaw)
            (COUNT(DISTINCT ?canonicalSource) as ?countCanonical)
            (GROUP_CONCAT(DISTINCT ?sourceLabel; SEPARATOR="|") as ?sourceLabels)
        WHERE {
            ?project1 a ptp:Project ;
                ptp:hasExternalData ?sharedExternalSource .

            ?project2 a ptp:Project ;
                ptp:hasExternalData ?sharedExternalSource .

            OPTIONAL {
                ?sharedExternalSource dct:title|rdfs:label ?sourceLabel .
            }

            OPTIONAL {
                ?sharedExternalSource dct:isVersionOf ?sharedVersionOf .
            }
            OPTIONAL {
                ?sharedExternalSource ptp:inputPattern ?sharedInputPattern .
            }
            BIND(COALESCE(?sharedVersionOf, URI(CONCAT("file://", ?sharedExternalSource))) AS ?canonicalSource)

            FILTER (?project1 != ?project2)
            FILTER (STR(?project1) < STR(?project2))
        }
        GROUP BY ?project1 ?project2
    }
    
    # Now get individual canonical sources for the same project pairs
    ?project1 ptp:hasExternalData ?sharedExternalSource .
    ?project2 ptp:hasExternalData ?sharedExternalSource .
    
    OPTIONAL {
        ?sharedExternalSource dct:isVersionOf ?sharedVersionOf .
    }
    OPTIONAL {
        ?sharedExternalSource ptp:inputPattern ?sharedInputPattern .
    }
    BIND(COALESCE(?sharedVersionOf, URI(CONCAT("file://", ?sharedExternalSource))) AS ?canonicalSource)
    
    # Create a unique IRI based on the project pair
    BIND(IRI(CONCAT("http://example.org/pythinfer/relationship/", 
                    MD5(CONCAT(STR(?project1), "|", STR(?project2))))) AS ?rel)
}
