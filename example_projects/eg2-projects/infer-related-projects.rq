BASE <http://www.example.org/>
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX eg: <http://www.example.org/>
PREFIX ptp: <http://www.example.org/pythinfer/project/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

# ===== SPARQL CONSTRUCT: Project Relationships =====
# 
# This query infers that two projects are related if they share external
# data sources (reference vocabularies). Projects are considered related if
# their external data shares either the same isVersionOf source OR the same
# inputPattern. This type of graph traversal and aggregation is difficult
# to express in OWL-RL and benefits from procedural query logic.
#
# It demonstrates:
# 1. Complex path traversal (project -> external data -> other projects)
# 2. Aggregation and filtering logic (finding common vocabularies)
# 3. Conditional inference based on graph patterns
#
# TODO:
# 1. Examine blank nodes used for sharedExternalSource to determine if relationships can be traced back to specific shared data sources
# 2. Add internal datasources
# 3. Add other connections between projects (e.g., shared authors, institutions, topics)

CONSTRUCT {
   # Create a ProjectRelationship between related projects
   ?rel a ptp:ProjectRelationship ;
       ptp:hasParticipant ?project1, ?project2 ;
       ptp:relationshipWeight ?countCanonical ;
       ptp:fullSharedCount ?countRaw ;
       ptp:sharedDataSourceLabels ?sourceLabels ;
       .
   
   # Add individual assertions for each shared data source
   ?rel ptp:sharedCanonicalDataSource ?canonicalSource .
   ?rel ptp:sharedDataSource ?sharedExternalSource .

   # This forces the serialisation to give a specific blank node ID (_:<id>) to the sharedExternalSource
   ?project1 ptp:hasDataSource ?sharedExternalSource .
   ?project2 ptp:hasDataSource ?sharedExternalSource .
   ?project1 ptp:identifiedBy ?project1Sanitised .
   ?project2 ptp:identifiedBy ?project2Sanitised .
}
WHERE {
    # Define valid project pairs once - filters applied here only
    {
        ?project1 a ptp:Project ;
            ptp:hasExternalData ?sharedExternalSource .

        ?project2 a ptp:Project ;
            ptp:hasExternalData ?sharedExternalSource .

        FILTER (?project1 != ?project2)
        FILTER (STR(?project1) < STR(?project2))

        # Extract local names and sanitize for use in IRIs
        # Keep only alphanumerics, hyphens, underscores, and periods
        # If project doesn't use eg: prefix, use the full IRI
        BIND(STRAFTER(STR(?project1), STR(eg:)) AS ?project1Local)
        BIND(STRAFTER(STR(?project2), STR(eg:)) AS ?project2Local)
        BIND(REPLACE(IF(?project1Local != "", ?project1Local, STR(?project1)), "[^a-zA-Z0-9._]", "_") AS ?project1Sanitised)
        BIND(REPLACE(IF(?project2Local != "", ?project2Local, STR(?project2)), "[^a-zA-Z0-9._]", "_") AS ?project2Sanitised)
    }
    
    # Get aggregated counts for the project pair (inherits project1/project2/sharedExternalSource bindings)
    {
        SELECT
            ?project1
            ?project2
            (COUNT(DISTINCT ?src) as ?countRaw)
            (COUNT(DISTINCT ?canon) as ?countCanonical)
            (GROUP_CONCAT(DISTINCT ?lbl; SEPARATOR="|") as ?sourceLabels)
        WHERE {
            ?project1 ptp:hasExternalData ?src .
            ?project2 ptp:hasExternalData ?src .

            OPTIONAL {
                ?src dct:title|rdfs:label ?lbl .
            }

            OPTIONAL {
                ?src dct:isVersionOf ?ver .
            }
            OPTIONAL {
                ?src ptp:inputPattern ?pat .
            }
            BIND(COALESCE(?ver, URI(CONCAT("file://", ?src))) AS ?canon)
        }
        GROUP BY ?project1 ?project2
    }
    
    # Get canonical source for each shared external source
    OPTIONAL {
        ?sharedExternalSource dct:isVersionOf ?sharedVersionOf .
    }
    OPTIONAL {
        ?sharedExternalSource ptp:inputPattern ?sharedInputPattern .
    }
    BIND(COALESCE(?sharedVersionOf, URI(CONCAT("file://", ?sharedExternalSource))) AS ?canonicalSource)
    
    # Create a unique IRI based on the project pair
    BIND(IRI(CONCAT("relationship-", ?project1Sanitised, "-", ?project2Sanitised)) AS ?rel)
}
