BASE <http://www.example.org/>
PREFIX dct: <http://purl.org/dc/terms/>
PREFIX eg: <http://www.example.org/>
PREFIX ptp: <http://www.example.org/pythinfer/project/>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>

# ===== SPARQL CONSTRUCT: Project Relationships =====
# 
# This query infers that two projects are related if they share external
# data sources (reference vocabularies). Projects are considered related if
# their external data shares either the same isVersionOf source OR the same
# inputPattern. This type of graph traversal and aggregation is difficult
# to express in OWL-RL and benefits from procedural query logic.
#
# It demonstrates:
# 1. Complex path traversal (project -> external data -> other projects)
# 2. Aggregation and filtering logic (finding common vocabularies)
# 3. Conditional inference based on graph patterns
#
# TODO:
# 1. Examine blank nodes used for sharedDataSource to determine if relationships can be traced back to specific shared data sources

CONSTRUCT {
   # Create a ProjectRelationship between related projects
   ?rel a ptp:ProjectRelationship ;
       ptp:hasParticipant ?project1, ?project2 ;
       ptp:relationshipWeight ?totalCanonicalWeighted ;
       ptp:countSharedExternalCanonicalSources ?countCanonicalExternal ;
       ptp:countSharedInternalCanonicalSources ?countCanonicalInternal ;
       ptp:countSharedExternalSources ?countRawExternal ;
       ptp:countSharedInternalSources ?countRawInternal ;
       ptp:sharedDataSourceLabels ?sourceLabels ;
       .
   
   # Add individual assertions for each shared data source
   ?rel ptp:sharedCanonicalDataSource ?canonicalSource .
   ?rel ptp:sharedDataSource ?sharedDataSource .

   ?project1 ptp:identifiedBy ?project1Sanitised .
   ?project2 ptp:identifiedBy ?project2Sanitised .

   # This forces the serialisation to give a specific blank node ID (_:<id>) to the sharedExternalSource
   ?project1 ptp:hasDataSource ?sharedDataSource .
   ?project2 ptp:hasDataSource ?sharedDataSource .
}
WHERE {
    # Define valid project pairs once - filters applied here only
    {
        ?project1 a ptp:Project ;
            ptp:hasDataSource ?sharedDataSource .

        ?project2 a ptp:Project ;
            ptp:hasDataSource ?sharedDataSource .

        FILTER (?project1 != ?project2)
        FILTER (STR(?project1) < STR(?project2))

        # Extract local names and sanitize for use in IRIs
        # Keep only alphanumerics, hyphens, underscores, and periods
        # If project doesn't use eg: prefix, use the full IRI
        BIND(STRAFTER(STR(?project1), STR(eg:)) AS ?project1Local)
        BIND(STRAFTER(STR(?project2), STR(eg:)) AS ?project2Local)
        BIND(REPLACE(IF(?project1Local != "", ?project1Local, STR(?project1)), "[^a-zA-Z0-9._]", "_") AS ?project1Sanitised)
        BIND(REPLACE(IF(?project2Local != "", ?project2Local, STR(?project2)), "[^a-zA-Z0-9._]", "_") AS ?project2Sanitised)
    }
    
    # Get aggregated counts for the project pair (inherits project1/project2/sharedExternalSource bindings)
    OPTIONAL {
        SELECT
            ?project1
            ?project2
            (COUNT(DISTINCT ?src) as ?countRawExternal)
            (COUNT(DISTINCT ?canon) as ?countCanonicalExternal)
            (GROUP_CONCAT(DISTINCT ?lbl; SEPARATOR="|") as ?externalSourceLabels)
        WHERE {
            ?project1 ptp:hasExternalData ?src .
            ?project2 ptp:hasExternalData ?src .

            OPTIONAL {
                ?src dct:title|rdfs:label ?lbl .
            }

            OPTIONAL {
                ?src dct:isVersionOf ?ver .
            }
            OPTIONAL {
                ?src ptp:inputPattern ?pat .
            }
            BIND(COALESCE(?ver, URI(CONCAT("file://", ?src))) AS ?canon)
        }
        GROUP BY ?project1 ?project2
    }
    OPTIONAL {
        SELECT
            ?project1
            ?project2
            (COUNT(DISTINCT ?src) as ?countRawInternal)
            (COUNT(DISTINCT ?canon) as ?countCanonicalInternal)
            (GROUP_CONCAT(DISTINCT ?lbl; SEPARATOR="|") as ?internalSourceLabels)
        WHERE {
            ?project1 ptp:hasInternalData ?src .
            ?project2 ptp:hasInternalData ?src .

            OPTIONAL {
                ?src dct:title|rdfs:label ?lbl .
            }

            OPTIONAL {
                ?src dct:isVersionOf ?ver .
            }
            OPTIONAL {
                ?src ptp:inputPattern ?pat .
            }
            BIND(COALESCE(?ver, URI(CONCAT("file://", ?pat))) AS ?canon)
        }
        GROUP BY ?project1 ?project2
    }
    
    # Get canonical source for each shared external source
    OPTIONAL {
        ?sharedDataSource dct:isVersionOf ?sharedVersionOf .
    }
    OPTIONAL {
        ?sharedDataSource ptp:inputPattern ?sharedInputPattern .
    }
    BIND(COALESCE(?sharedVersionOf, URI(CONCAT("file://", ?sharedInputPattern))) AS ?canonicalSource)

    # Handle cases where one or both label sets might be unbound
    BIND(COALESCE(?externalSourceLabels, "") AS ?extLabels)
    BIND(COALESCE(?internalSourceLabels, "") AS ?intLabels)
    BIND(IF(?extLabels != "" && ?intLabels != "", CONCAT(?extLabels, "|", ?intLabels),
         IF(?extLabels != "", ?extLabels, ?intLabels)) AS ?sourceLabels)

    BIND(COALESCE(?countCanonicalExternal, 0) + (3*COALESCE(?countCanonicalInternal, 0)) AS ?totalCanonicalWeighted)

    # Create a unique IRI based on the project pair
    BIND(IRI(CONCAT("relationship-", ?project1Sanitised, "-", ?project2Sanitised)) AS ?rel)
}
